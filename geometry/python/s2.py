# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_s2', [dirname(__file__)])
        except ImportError:
            import _s2
            return _s2
        if fp is not None:
            try:
                _mod = imp.load_module('_s2', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _s2 = swig_import_helper()
    del swig_import_helper
else:
    import _s2
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _s2.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _s2.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _s2.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _s2.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _s2.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _s2.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _s2.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _s2.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _s2.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _s2.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _s2.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _s2.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _s2.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _s2.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _s2.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _s2.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _s2.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def FromS2CellId(*args) -> "PyObject *" :
  return _s2.FromS2CellId(*args)
FromS2CellId = _s2.FromS2CellId
class R1Interval(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, R1Interval, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, R1Interval, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _s2.new_R1Interval(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["Empty"] = lambda x: _s2.R1Interval_Empty
    if _newclass:Empty = staticmethod(_s2.R1Interval_Empty)
    __swig_getmethods__["FromPoint"] = lambda x: _s2.R1Interval_FromPoint
    if _newclass:FromPoint = staticmethod(_s2.R1Interval_FromPoint)
    __swig_getmethods__["FromPointPair"] = lambda x: _s2.R1Interval_FromPointPair
    if _newclass:FromPointPair = staticmethod(_s2.R1Interval_FromPointPair)
    def lo(self) -> "double" : return _s2.R1Interval_lo(self)
    def hi(self) -> "double" : return _s2.R1Interval_hi(self)
    def bound(self, *args) -> "double" : return _s2.R1Interval_bound(self, *args)
    def bounds(self) -> "Vector2_d const &" : return _s2.R1Interval_bounds(self)
    def set_lo(self, *args) -> "void" : return _s2.R1Interval_set_lo(self, *args)
    def set_hi(self, *args) -> "void" : return _s2.R1Interval_set_hi(self, *args)
    def is_empty(self) -> "bool" : return _s2.R1Interval_is_empty(self)
    def GetCenter(self) -> "double" : return _s2.R1Interval_GetCenter(self)
    def GetLength(self) -> "double" : return _s2.R1Interval_GetLength(self)
    def Contains(self, *args) -> "bool" : return _s2.R1Interval_Contains(self, *args)
    def InteriorContains(self, *args) -> "bool" : return _s2.R1Interval_InteriorContains(self, *args)
    def Intersects(self, *args) -> "bool" : return _s2.R1Interval_Intersects(self, *args)
    def InteriorIntersects(self, *args) -> "bool" : return _s2.R1Interval_InteriorIntersects(self, *args)
    def GetDirectedHausdorffDistance(self, *args) -> "double" : return _s2.R1Interval_GetDirectedHausdorffDistance(self, *args)
    def AddPoint(self, *args) -> "void" : return _s2.R1Interval_AddPoint(self, *args)
    def Expanded(self, *args) -> "R1Interval" : return _s2.R1Interval_Expanded(self, *args)
    def Union(self, *args) -> "R1Interval" : return _s2.R1Interval_Union(self, *args)
    def Intersection(self, *args) -> "R1Interval" : return _s2.R1Interval_Intersection(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.R1Interval___eq__(self, *args)
    def ApproxEquals(self, *args) -> "bool" : return _s2.R1Interval_ApproxEquals(self, *args)
    __swig_destroy__ = _s2.delete_R1Interval
    __del__ = lambda self : None;
R1Interval_swigregister = _s2.R1Interval_swigregister
R1Interval_swigregister(R1Interval)

def R1Interval_Empty() -> "R1Interval" :
  return _s2.R1Interval_Empty()
R1Interval_Empty = _s2.R1Interval_Empty

def R1Interval_FromPoint(*args) -> "R1Interval" :
  return _s2.R1Interval_FromPoint(*args)
R1Interval_FromPoint = _s2.R1Interval_FromPoint

def R1Interval_FromPointPair(*args) -> "R1Interval" :
  return _s2.R1Interval_FromPointPair(*args)
R1Interval_FromPointPair = _s2.R1Interval_FromPointPair

class S1Angle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S1Angle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S1Angle, name)
    __repr__ = _swig_repr
    __swig_getmethods__["Radians"] = lambda x: _s2.S1Angle_Radians
    if _newclass:Radians = staticmethod(_s2.S1Angle_Radians)
    __swig_getmethods__["Degrees"] = lambda x: _s2.S1Angle_Degrees
    if _newclass:Degrees = staticmethod(_s2.S1Angle_Degrees)
    __swig_getmethods__["E5"] = lambda x: _s2.S1Angle_E5
    if _newclass:E5 = staticmethod(_s2.S1Angle_E5)
    __swig_getmethods__["E6"] = lambda x: _s2.S1Angle_E6
    if _newclass:E6 = staticmethod(_s2.S1Angle_E6)
    __swig_getmethods__["E7"] = lambda x: _s2.S1Angle_E7
    if _newclass:E7 = staticmethod(_s2.S1Angle_E7)
    __swig_getmethods__["UnsignedE6"] = lambda x: _s2.S1Angle_UnsignedE6
    if _newclass:UnsignedE6 = staticmethod(_s2.S1Angle_UnsignedE6)
    __swig_getmethods__["UnsignedE7"] = lambda x: _s2.S1Angle_UnsignedE7
    if _newclass:UnsignedE7 = staticmethod(_s2.S1Angle_UnsignedE7)
    def __init__(self, *args): 
        this = _s2.new_S1Angle(*args)
        try: self.this.append(this)
        except: self.this = this
    def radians(self) -> "double" : return _s2.S1Angle_radians(self)
    def degrees(self) -> "double" : return _s2.S1Angle_degrees(self)
    def e5(self) -> "int32" : return _s2.S1Angle_e5(self)
    def e6(self) -> "int32" : return _s2.S1Angle_e6(self)
    def e7(self) -> "int32" : return _s2.S1Angle_e7(self)
    def abs(self) -> "S1Angle" : return _s2.S1Angle_abs(self)
    def __iadd__(self, *args) -> "S1Angle &" : return _s2.S1Angle___iadd__(self, *args)
    def __isub__(self, *args) -> "S1Angle &" : return _s2.S1Angle___isub__(self, *args)
    def __imul__(self, *args) -> "S1Angle &" : return _s2.S1Angle___imul__(self, *args)
    def __idiv__(self, *args) -> "S1Angle &" : return _s2.S1Angle___idiv__(self, *args)
    def Normalized(self) -> "S1Angle" : return _s2.S1Angle_Normalized(self)
    def Normalize(self) -> "void" : return _s2.S1Angle_Normalize(self)
    def __str__(self) -> "string" : return _s2.S1Angle___str__(self)
    __swig_destroy__ = _s2.delete_S1Angle
    __del__ = lambda self : None;
S1Angle_swigregister = _s2.S1Angle_swigregister
S1Angle_swigregister(S1Angle)

def S1Angle_Radians(*args) -> "S1Angle" :
  return _s2.S1Angle_Radians(*args)
S1Angle_Radians = _s2.S1Angle_Radians

def S1Angle_Degrees(*args) -> "S1Angle" :
  return _s2.S1Angle_Degrees(*args)
S1Angle_Degrees = _s2.S1Angle_Degrees

def S1Angle_E5(*args) -> "S1Angle" :
  return _s2.S1Angle_E5(*args)
S1Angle_E5 = _s2.S1Angle_E5

def S1Angle_E6(*args) -> "S1Angle" :
  return _s2.S1Angle_E6(*args)
S1Angle_E6 = _s2.S1Angle_E6

def S1Angle_E7(*args) -> "S1Angle" :
  return _s2.S1Angle_E7(*args)
S1Angle_E7 = _s2.S1Angle_E7

def S1Angle_UnsignedE6(*args) -> "S1Angle" :
  return _s2.S1Angle_UnsignedE6(*args)
S1Angle_UnsignedE6 = _s2.S1Angle_UnsignedE6

def S1Angle_UnsignedE7(*args) -> "S1Angle" :
  return _s2.S1Angle_UnsignedE7(*args)
S1Angle_UnsignedE7 = _s2.S1Angle_UnsignedE7

class S1Interval(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S1Interval, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S1Interval, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _s2.new_S1Interval(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["Empty"] = lambda x: _s2.S1Interval_Empty
    if _newclass:Empty = staticmethod(_s2.S1Interval_Empty)
    __swig_getmethods__["Full"] = lambda x: _s2.S1Interval_Full
    if _newclass:Full = staticmethod(_s2.S1Interval_Full)
    __swig_getmethods__["FromPoint"] = lambda x: _s2.S1Interval_FromPoint
    if _newclass:FromPoint = staticmethod(_s2.S1Interval_FromPoint)
    __swig_getmethods__["FromPointPair"] = lambda x: _s2.S1Interval_FromPointPair
    if _newclass:FromPointPair = staticmethod(_s2.S1Interval_FromPointPair)
    def lo(self) -> "double" : return _s2.S1Interval_lo(self)
    def hi(self) -> "double" : return _s2.S1Interval_hi(self)
    def bound(self, *args) -> "double" : return _s2.S1Interval_bound(self, *args)
    def bounds(self) -> "Vector2_d const &" : return _s2.S1Interval_bounds(self)
    def set_lo(self, *args) -> "void" : return _s2.S1Interval_set_lo(self, *args)
    def set_hi(self, *args) -> "void" : return _s2.S1Interval_set_hi(self, *args)
    def is_valid(self) -> "bool" : return _s2.S1Interval_is_valid(self)
    def is_full(self) -> "bool" : return _s2.S1Interval_is_full(self)
    def is_empty(self) -> "bool" : return _s2.S1Interval_is_empty(self)
    def is_inverted(self) -> "bool" : return _s2.S1Interval_is_inverted(self)
    def GetCenter(self) -> "double" : return _s2.S1Interval_GetCenter(self)
    def GetLength(self) -> "double" : return _s2.S1Interval_GetLength(self)
    def Complement(self) -> "S1Interval" : return _s2.S1Interval_Complement(self)
    def GetComplementCenter(self) -> "double" : return _s2.S1Interval_GetComplementCenter(self)
    def Contains(self, *args) -> "bool" : return _s2.S1Interval_Contains(self, *args)
    def InteriorContains(self, *args) -> "bool" : return _s2.S1Interval_InteriorContains(self, *args)
    def Intersects(self, *args) -> "bool" : return _s2.S1Interval_Intersects(self, *args)
    def InteriorIntersects(self, *args) -> "bool" : return _s2.S1Interval_InteriorIntersects(self, *args)
    def GetDirectedHausdorffDistance(self, *args) -> "double" : return _s2.S1Interval_GetDirectedHausdorffDistance(self, *args)
    def AddPoint(self, *args) -> "void" : return _s2.S1Interval_AddPoint(self, *args)
    def Expanded(self, *args) -> "S1Interval" : return _s2.S1Interval_Expanded(self, *args)
    def Union(self, *args) -> "S1Interval" : return _s2.S1Interval_Union(self, *args)
    def Intersection(self, *args) -> "S1Interval" : return _s2.S1Interval_Intersection(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.S1Interval___eq__(self, *args)
    def ApproxEquals(self, *args) -> "bool" : return _s2.S1Interval_ApproxEquals(self, *args)
    def __str__(self) -> "string" : return _s2.S1Interval___str__(self)
    __swig_destroy__ = _s2.delete_S1Interval
    __del__ = lambda self : None;
S1Interval_swigregister = _s2.S1Interval_swigregister
S1Interval_swigregister(S1Interval)

def S1Interval_Empty() -> "S1Interval" :
  return _s2.S1Interval_Empty()
S1Interval_Empty = _s2.S1Interval_Empty

def S1Interval_Full() -> "S1Interval" :
  return _s2.S1Interval_Full()
S1Interval_Full = _s2.S1Interval_Full

def S1Interval_FromPoint(*args) -> "S1Interval" :
  return _s2.S1Interval_FromPoint(*args)
S1Interval_FromPoint = _s2.S1Interval_FromPoint

def S1Interval_FromPointPair(*args) -> "S1Interval" :
  return _s2.S1Interval_FromPointPair(*args)
S1Interval_FromPointPair = _s2.S1Interval_FromPointPair

class S2CellId(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2CellId, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S2CellId, name)
    __repr__ = _swig_repr
    kFaceBits = _s2.S2CellId_kFaceBits
    kNumFaces = _s2.S2CellId_kNumFaces
    kMaxLevel = _s2.S2CellId_kMaxLevel
    kPosBits = _s2.S2CellId_kPosBits
    kMaxSize = _s2.S2CellId_kMaxSize
    def __init__(self, *args): 
        this = _s2.new_S2CellId(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["Sentinel"] = lambda x: _s2.S2CellId_Sentinel
    if _newclass:Sentinel = staticmethod(_s2.S2CellId_Sentinel)
    __swig_getmethods__["FromFacePosLevel"] = lambda x: _s2.S2CellId_FromFacePosLevel
    if _newclass:FromFacePosLevel = staticmethod(_s2.S2CellId_FromFacePosLevel)
    __swig_getmethods__["FromPoint"] = lambda x: _s2.S2CellId_FromPoint
    if _newclass:FromPoint = staticmethod(_s2.S2CellId_FromPoint)
    __swig_getmethods__["FromLatLng"] = lambda x: _s2.S2CellId_FromLatLng
    if _newclass:FromLatLng = staticmethod(_s2.S2CellId_FromLatLng)
    def ToPoint(self) -> "S2Point" : return _s2.S2CellId_ToPoint(self)
    def ToPointRaw(self) -> "S2Point" : return _s2.S2CellId_ToPointRaw(self)
    def GetCenterST(self) -> "Vector2_d" : return _s2.S2CellId_GetCenterST(self)
    def GetCenterUV(self) -> "Vector2_d" : return _s2.S2CellId_GetCenterUV(self)
    def ToLatLng(self) -> "S2LatLng" : return _s2.S2CellId_ToLatLng(self)
    def id(self) -> "uint64" : return _s2.S2CellId_id(self)
    def is_valid(self) -> "bool" : return _s2.S2CellId_is_valid(self)
    def face(self) -> "int" : return _s2.S2CellId_face(self)
    def pos(self) -> "uint64" : return _s2.S2CellId_pos(self)
    def level(self) -> "int" : return _s2.S2CellId_level(self)
    __swig_getmethods__["GetSizeIJ"] = lambda x: _s2.S2CellId_GetSizeIJ
    if _newclass:GetSizeIJ = staticmethod(_s2.S2CellId_GetSizeIJ)
    __swig_getmethods__["GetSizeST"] = lambda x: _s2.S2CellId_GetSizeST
    if _newclass:GetSizeST = staticmethod(_s2.S2CellId_GetSizeST)
    def is_leaf(self) -> "bool" : return _s2.S2CellId_is_leaf(self)
    def is_face(self) -> "bool" : return _s2.S2CellId_is_face(self)
    def child_position(self, *args) -> "int" : return _s2.S2CellId_child_position(self, *args)
    def range_min(self) -> "S2CellId" : return _s2.S2CellId_range_min(self)
    def range_max(self) -> "S2CellId" : return _s2.S2CellId_range_max(self)
    def contains(self, *args) -> "bool" : return _s2.S2CellId_contains(self, *args)
    def intersects(self, *args) -> "bool" : return _s2.S2CellId_intersects(self, *args)
    def parent(self, *args) -> "S2CellId" : return _s2.S2CellId_parent(self, *args)
    def child(self, *args) -> "S2CellId" : return _s2.S2CellId_child(self, *args)
    def child_begin(self, *args) -> "S2CellId" : return _s2.S2CellId_child_begin(self, *args)
    def child_end(self, *args) -> "S2CellId" : return _s2.S2CellId_child_end(self, *args)
    def next(self) -> "S2CellId" : return _s2.S2CellId_next(self)
    def prev(self) -> "S2CellId" : return _s2.S2CellId_prev(self)
    def advance(self, *args) -> "S2CellId" : return _s2.S2CellId_advance(self, *args)
    def next_wrap(self) -> "S2CellId" : return _s2.S2CellId_next_wrap(self)
    def prev_wrap(self) -> "S2CellId" : return _s2.S2CellId_prev_wrap(self)
    def advance_wrap(self, *args) -> "S2CellId" : return _s2.S2CellId_advance_wrap(self, *args)
    __swig_getmethods__["Begin"] = lambda x: _s2.S2CellId_Begin
    if _newclass:Begin = staticmethod(_s2.S2CellId_Begin)
    __swig_getmethods__["End"] = lambda x: _s2.S2CellId_End
    if _newclass:End = staticmethod(_s2.S2CellId_End)
    def ToToken(self) -> "string" : return _s2.S2CellId_ToToken(self)
    __swig_getmethods__["FromToken"] = lambda x: _s2.S2CellId_FromToken
    if _newclass:FromToken = staticmethod(_s2.S2CellId_FromToken)
    def ToString(self) -> "string" : return _s2.S2CellId_ToString(self)
    def GetEdgeNeighbors(self, *args) -> "void" : return _s2.S2CellId_GetEdgeNeighbors(self, *args)
    def AppendVertexNeighbors(self, *args) -> "void" : return _s2.S2CellId_AppendVertexNeighbors(self, *args)
    def AppendAllNeighbors(self, *args) -> "void" : return _s2.S2CellId_AppendAllNeighbors(self, *args)
    __swig_getmethods__["FromFaceIJ"] = lambda x: _s2.S2CellId_FromFaceIJ
    if _newclass:FromFaceIJ = staticmethod(_s2.S2CellId_FromFaceIJ)
    def ToFaceIJOrientation(self, *args) -> "int" : return _s2.S2CellId_ToFaceIJOrientation(self, *args)
    def lsb(self) -> "uint64" : return _s2.S2CellId_lsb(self)
    __swig_getmethods__["lsb_for_level"] = lambda x: _s2.S2CellId_lsb_for_level
    if _newclass:lsb_for_level = staticmethod(_s2.S2CellId_lsb_for_level)
    def __str__(self) -> "string" : return _s2.S2CellId___str__(self)
    def __eq__(self, *args) -> "bool" : return _s2.S2CellId___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _s2.S2CellId___ne__(self, *args)
    def __lt__(self, *args) -> "bool" : return _s2.S2CellId___lt__(self, *args)
    def __gt__(self, *args) -> "bool" : return _s2.S2CellId___gt__(self, *args)
    __swig_destroy__ = _s2.delete_S2CellId
    __del__ = lambda self : None;
S2CellId_swigregister = _s2.S2CellId_swigregister
S2CellId_swigregister(S2CellId)

def S2CellId_Sentinel() -> "S2CellId" :
  return _s2.S2CellId_Sentinel()
S2CellId_Sentinel = _s2.S2CellId_Sentinel

def S2CellId_FromFacePosLevel(*args) -> "S2CellId" :
  return _s2.S2CellId_FromFacePosLevel(*args)
S2CellId_FromFacePosLevel = _s2.S2CellId_FromFacePosLevel

def S2CellId_FromPoint(*args) -> "S2CellId" :
  return _s2.S2CellId_FromPoint(*args)
S2CellId_FromPoint = _s2.S2CellId_FromPoint

def S2CellId_FromLatLng(*args) -> "S2CellId" :
  return _s2.S2CellId_FromLatLng(*args)
S2CellId_FromLatLng = _s2.S2CellId_FromLatLng

def S2CellId_GetSizeIJ(*args) -> "int" :
  return _s2.S2CellId_GetSizeIJ(*args)
S2CellId_GetSizeIJ = _s2.S2CellId_GetSizeIJ

def S2CellId_GetSizeST(*args) -> "double" :
  return _s2.S2CellId_GetSizeST(*args)
S2CellId_GetSizeST = _s2.S2CellId_GetSizeST

def S2CellId_Begin(*args) -> "S2CellId" :
  return _s2.S2CellId_Begin(*args)
S2CellId_Begin = _s2.S2CellId_Begin

def S2CellId_End(*args) -> "S2CellId" :
  return _s2.S2CellId_End(*args)
S2CellId_End = _s2.S2CellId_End

def S2CellId_FromToken(*args) -> "S2CellId" :
  return _s2.S2CellId_FromToken(*args)
S2CellId_FromToken = _s2.S2CellId_FromToken

def S2CellId_FromFaceIJ(*args) -> "S2CellId" :
  return _s2.S2CellId_FromFaceIJ(*args)
S2CellId_FromFaceIJ = _s2.S2CellId_FromFaceIJ

def S2CellId_lsb_for_level(*args) -> "uint64" :
  return _s2.S2CellId_lsb_for_level(*args)
S2CellId_lsb_for_level = _s2.S2CellId_lsb_for_level

class S2Region(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2Region, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S2Region, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _s2.delete_S2Region
    __del__ = lambda self : None;
    def Clone(self) -> "S2Region *" : return _s2.S2Region_Clone(self)
    def GetCapBound(self) -> "S2Cap" : return _s2.S2Region_GetCapBound(self)
    def GetRectBound(self) -> "S2LatLngRect" : return _s2.S2Region_GetRectBound(self)
    def Contains(self, *args) -> "bool" : return _s2.S2Region_Contains(self, *args)
    def MayIntersect(self, *args) -> "bool" : return _s2.S2Region_MayIntersect(self, *args)
    def VirtualContainsPoint(self, *args) -> "bool" : return _s2.S2Region_VirtualContainsPoint(self, *args)
    def Encode(self, *args) -> "void" : return _s2.S2Region_Encode(self, *args)
    def Decode(self, *args) -> "bool" : return _s2.S2Region_Decode(self, *args)
    def DecodeWithinScope(self, *args) -> "bool" : return _s2.S2Region_DecodeWithinScope(self, *args)
S2Region_swigregister = _s2.S2Region_swigregister
S2Region_swigregister(S2Region)

class S2Cap(S2Region):
    __swig_setmethods__ = {}
    for _s in [S2Region]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2Cap, name, value)
    __swig_getmethods__ = {}
    for _s in [S2Region]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, S2Cap, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _s2.new_S2Cap()
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["FromAxisHeight"] = lambda x: _s2.S2Cap_FromAxisHeight
    if _newclass:FromAxisHeight = staticmethod(_s2.S2Cap_FromAxisHeight)
    __swig_getmethods__["FromAxisAngle"] = lambda x: _s2.S2Cap_FromAxisAngle
    if _newclass:FromAxisAngle = staticmethod(_s2.S2Cap_FromAxisAngle)
    __swig_getmethods__["FromAxisArea"] = lambda x: _s2.S2Cap_FromAxisArea
    if _newclass:FromAxisArea = staticmethod(_s2.S2Cap_FromAxisArea)
    __swig_getmethods__["Empty"] = lambda x: _s2.S2Cap_Empty
    if _newclass:Empty = staticmethod(_s2.S2Cap_Empty)
    __swig_getmethods__["Full"] = lambda x: _s2.S2Cap_Full
    if _newclass:Full = staticmethod(_s2.S2Cap_Full)
    __swig_destroy__ = _s2.delete_S2Cap
    __del__ = lambda self : None;
    def axis(self) -> "S2Point const &" : return _s2.S2Cap_axis(self)
    def height(self) -> "double" : return _s2.S2Cap_height(self)
    def area(self) -> "double" : return _s2.S2Cap_area(self)
    def angle(self) -> "S1Angle" : return _s2.S2Cap_angle(self)
    def is_valid(self) -> "bool" : return _s2.S2Cap_is_valid(self)
    def is_empty(self) -> "bool" : return _s2.S2Cap_is_empty(self)
    def is_full(self) -> "bool" : return _s2.S2Cap_is_full(self)
    def Complement(self) -> "S2Cap" : return _s2.S2Cap_Complement(self)
    def Intersects(self, *args) -> "bool" : return _s2.S2Cap_Intersects(self, *args)
    def InteriorIntersects(self, *args) -> "bool" : return _s2.S2Cap_InteriorIntersects(self, *args)
    def InteriorContains(self, *args) -> "bool" : return _s2.S2Cap_InteriorContains(self, *args)
    def AddPoint(self, *args) -> "void" : return _s2.S2Cap_AddPoint(self, *args)
    def AddCap(self, *args) -> "void" : return _s2.S2Cap_AddCap(self, *args)
    def Expanded(self, *args) -> "S2Cap" : return _s2.S2Cap_Expanded(self, *args)
    def Clone(self) -> "S2Cap *" : return _s2.S2Cap_Clone(self)
    def GetCapBound(self) -> "S2Cap" : return _s2.S2Cap_GetCapBound(self)
    def GetRectBound(self) -> "S2LatLngRect" : return _s2.S2Cap_GetRectBound(self)
    def MayIntersect(self, *args) -> "bool" : return _s2.S2Cap_MayIntersect(self, *args)
    def VirtualContainsPoint(self, *args) -> "bool" : return _s2.S2Cap_VirtualContainsPoint(self, *args)
    def Contains(self, *args) -> "bool" : return _s2.S2Cap_Contains(self, *args)
    def Encode(self, *args) -> "void" : return _s2.S2Cap_Encode(self, *args)
    def Decode(self, *args) -> "bool" : return _s2.S2Cap_Decode(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.S2Cap___eq__(self, *args)
    def ApproxEquals(self, *args) -> "bool" : return _s2.S2Cap_ApproxEquals(self, *args)
    def __str__(self) -> "string" : return _s2.S2Cap___str__(self)
S2Cap_swigregister = _s2.S2Cap_swigregister
S2Cap_swigregister(S2Cap)

def S2Cap_FromAxisHeight(*args) -> "S2Cap" :
  return _s2.S2Cap_FromAxisHeight(*args)
S2Cap_FromAxisHeight = _s2.S2Cap_FromAxisHeight

def S2Cap_FromAxisAngle(*args) -> "S2Cap" :
  return _s2.S2Cap_FromAxisAngle(*args)
S2Cap_FromAxisAngle = _s2.S2Cap_FromAxisAngle

def S2Cap_FromAxisArea(*args) -> "S2Cap" :
  return _s2.S2Cap_FromAxisArea(*args)
S2Cap_FromAxisArea = _s2.S2Cap_FromAxisArea

def S2Cap_Empty() -> "S2Cap" :
  return _s2.S2Cap_Empty()
S2Cap_Empty = _s2.S2Cap_Empty

def S2Cap_Full() -> "S2Cap" :
  return _s2.S2Cap_Full()
S2Cap_Full = _s2.S2Cap_Full

class S2LatLng(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2LatLng, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S2LatLng, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _s2.new_S2LatLng(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["Invalid"] = lambda x: _s2.S2LatLng_Invalid
    if _newclass:Invalid = staticmethod(_s2.S2LatLng_Invalid)
    __swig_getmethods__["FromRadians"] = lambda x: _s2.S2LatLng_FromRadians
    if _newclass:FromRadians = staticmethod(_s2.S2LatLng_FromRadians)
    __swig_getmethods__["FromDegrees"] = lambda x: _s2.S2LatLng_FromDegrees
    if _newclass:FromDegrees = staticmethod(_s2.S2LatLng_FromDegrees)
    __swig_getmethods__["FromE5"] = lambda x: _s2.S2LatLng_FromE5
    if _newclass:FromE5 = staticmethod(_s2.S2LatLng_FromE5)
    __swig_getmethods__["FromE6"] = lambda x: _s2.S2LatLng_FromE6
    if _newclass:FromE6 = staticmethod(_s2.S2LatLng_FromE6)
    __swig_getmethods__["FromE7"] = lambda x: _s2.S2LatLng_FromE7
    if _newclass:FromE7 = staticmethod(_s2.S2LatLng_FromE7)
    __swig_getmethods__["FromUnsignedE6"] = lambda x: _s2.S2LatLng_FromUnsignedE6
    if _newclass:FromUnsignedE6 = staticmethod(_s2.S2LatLng_FromUnsignedE6)
    __swig_getmethods__["FromUnsignedE7"] = lambda x: _s2.S2LatLng_FromUnsignedE7
    if _newclass:FromUnsignedE7 = staticmethod(_s2.S2LatLng_FromUnsignedE7)
    __swig_getmethods__["Latitude"] = lambda x: _s2.S2LatLng_Latitude
    if _newclass:Latitude = staticmethod(_s2.S2LatLng_Latitude)
    __swig_getmethods__["Longitude"] = lambda x: _s2.S2LatLng_Longitude
    if _newclass:Longitude = staticmethod(_s2.S2LatLng_Longitude)
    def lat(self) -> "S1Angle" : return _s2.S2LatLng_lat(self)
    def lng(self) -> "S1Angle" : return _s2.S2LatLng_lng(self)
    def coords(self) -> "Vector2_d const &" : return _s2.S2LatLng_coords(self)
    def is_valid(self) -> "bool" : return _s2.S2LatLng_is_valid(self)
    def Normalized(self) -> "S2LatLng" : return _s2.S2LatLng_Normalized(self)
    def ToPoint(self) -> "S2Point" : return _s2.S2LatLng_ToPoint(self)
    def GetDistance(self, *args) -> "S1Angle" : return _s2.S2LatLng_GetDistance(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.S2LatLng___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _s2.S2LatLng___ne__(self, *args)
    def __lt__(self, *args) -> "bool" : return _s2.S2LatLng___lt__(self, *args)
    def __gt__(self, *args) -> "bool" : return _s2.S2LatLng___gt__(self, *args)
    def __le__(self, *args) -> "bool" : return _s2.S2LatLng___le__(self, *args)
    def __ge__(self, *args) -> "bool" : return _s2.S2LatLng___ge__(self, *args)
    def ApproxEquals(self, *args) -> "bool" : return _s2.S2LatLng_ApproxEquals(self, *args)
    def ToStringInDegrees(self, *args) -> "void" : return _s2.S2LatLng_ToStringInDegrees(self, *args)
    def __str__(self) -> "string" : return _s2.S2LatLng___str__(self)
    __swig_destroy__ = _s2.delete_S2LatLng
    __del__ = lambda self : None;
S2LatLng_swigregister = _s2.S2LatLng_swigregister
S2LatLng_swigregister(S2LatLng)

def S2LatLng_Invalid() -> "S2LatLng" :
  return _s2.S2LatLng_Invalid()
S2LatLng_Invalid = _s2.S2LatLng_Invalid

def S2LatLng_FromRadians(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromRadians(*args)
S2LatLng_FromRadians = _s2.S2LatLng_FromRadians

def S2LatLng_FromDegrees(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromDegrees(*args)
S2LatLng_FromDegrees = _s2.S2LatLng_FromDegrees

def S2LatLng_FromE5(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromE5(*args)
S2LatLng_FromE5 = _s2.S2LatLng_FromE5

def S2LatLng_FromE6(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromE6(*args)
S2LatLng_FromE6 = _s2.S2LatLng_FromE6

def S2LatLng_FromE7(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromE7(*args)
S2LatLng_FromE7 = _s2.S2LatLng_FromE7

def S2LatLng_FromUnsignedE6(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromUnsignedE6(*args)
S2LatLng_FromUnsignedE6 = _s2.S2LatLng_FromUnsignedE6

def S2LatLng_FromUnsignedE7(*args) -> "S2LatLng" :
  return _s2.S2LatLng_FromUnsignedE7(*args)
S2LatLng_FromUnsignedE7 = _s2.S2LatLng_FromUnsignedE7

def S2LatLng_Latitude(*args) -> "S1Angle" :
  return _s2.S2LatLng_Latitude(*args)
S2LatLng_Latitude = _s2.S2LatLng_Latitude

def S2LatLng_Longitude(*args) -> "S1Angle" :
  return _s2.S2LatLng_Longitude(*args)
S2LatLng_Longitude = _s2.S2LatLng_Longitude

class S2LatLngRect(S2Region):
    __swig_setmethods__ = {}
    for _s in [S2Region]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2LatLngRect, name, value)
    __swig_getmethods__ = {}
    for _s in [S2Region]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, S2LatLngRect, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _s2.new_S2LatLngRect(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_getmethods__["FromCenterSize"] = lambda x: _s2.S2LatLngRect_FromCenterSize
    if _newclass:FromCenterSize = staticmethod(_s2.S2LatLngRect_FromCenterSize)
    __swig_getmethods__["FromPoint"] = lambda x: _s2.S2LatLngRect_FromPoint
    if _newclass:FromPoint = staticmethod(_s2.S2LatLngRect_FromPoint)
    __swig_getmethods__["FromPointPair"] = lambda x: _s2.S2LatLngRect_FromPointPair
    if _newclass:FromPointPair = staticmethod(_s2.S2LatLngRect_FromPointPair)
    def lat_lo(self) -> "S1Angle" : return _s2.S2LatLngRect_lat_lo(self)
    def lat_hi(self) -> "S1Angle" : return _s2.S2LatLngRect_lat_hi(self)
    def lng_lo(self) -> "S1Angle" : return _s2.S2LatLngRect_lng_lo(self)
    def lng_hi(self) -> "S1Angle" : return _s2.S2LatLngRect_lng_hi(self)
    def lat(self) -> "R1Interval const &" : return _s2.S2LatLngRect_lat(self)
    def lng(self) -> "S1Interval const &" : return _s2.S2LatLngRect_lng(self)
    def mutable_lat(self) -> "R1Interval *" : return _s2.S2LatLngRect_mutable_lat(self)
    def mutable_lng(self) -> "S1Interval *" : return _s2.S2LatLngRect_mutable_lng(self)
    def lo(self) -> "S2LatLng" : return _s2.S2LatLngRect_lo(self)
    def hi(self) -> "S2LatLng" : return _s2.S2LatLngRect_hi(self)
    __swig_getmethods__["Empty"] = lambda x: _s2.S2LatLngRect_Empty
    if _newclass:Empty = staticmethod(_s2.S2LatLngRect_Empty)
    __swig_getmethods__["Full"] = lambda x: _s2.S2LatLngRect_Full
    if _newclass:Full = staticmethod(_s2.S2LatLngRect_Full)
    __swig_getmethods__["FullLat"] = lambda x: _s2.S2LatLngRect_FullLat
    if _newclass:FullLat = staticmethod(_s2.S2LatLngRect_FullLat)
    __swig_getmethods__["FullLng"] = lambda x: _s2.S2LatLngRect_FullLng
    if _newclass:FullLng = staticmethod(_s2.S2LatLngRect_FullLng)
    def is_valid(self) -> "bool" : return _s2.S2LatLngRect_is_valid(self)
    def is_empty(self) -> "bool" : return _s2.S2LatLngRect_is_empty(self)
    def is_full(self) -> "bool" : return _s2.S2LatLngRect_is_full(self)
    def is_point(self) -> "bool" : return _s2.S2LatLngRect_is_point(self)
    def is_inverted(self) -> "bool" : return _s2.S2LatLngRect_is_inverted(self)
    def GetVertex(self, *args) -> "S2LatLng" : return _s2.S2LatLngRect_GetVertex(self, *args)
    def GetCenter(self) -> "S2LatLng" : return _s2.S2LatLngRect_GetCenter(self)
    def GetSize(self) -> "S2LatLng" : return _s2.S2LatLngRect_GetSize(self)
    def Area(self) -> "double" : return _s2.S2LatLngRect_Area(self)
    def InteriorContains(self, *args) -> "bool" : return _s2.S2LatLngRect_InteriorContains(self, *args)
    def Intersects(self, *args) -> "bool" : return _s2.S2LatLngRect_Intersects(self, *args)
    def InteriorIntersects(self, *args) -> "bool" : return _s2.S2LatLngRect_InteriorIntersects(self, *args)
    def AddPoint(self, *args) -> "void" : return _s2.S2LatLngRect_AddPoint(self, *args)
    def Expanded(self, *args) -> "S2LatLngRect" : return _s2.S2LatLngRect_Expanded(self, *args)
    def Union(self, *args) -> "S2LatLngRect" : return _s2.S2LatLngRect_Union(self, *args)
    def Intersection(self, *args) -> "S2LatLngRect" : return _s2.S2LatLngRect_Intersection(self, *args)
    def ConvolveWithCap(self, *args) -> "S2LatLngRect" : return _s2.S2LatLngRect_ConvolveWithCap(self, *args)
    def GetDistance(self, *args) -> "S1Angle" : return _s2.S2LatLngRect_GetDistance(self, *args)
    def GetDirectedHausdorffDistance(self, *args) -> "S1Angle" : return _s2.S2LatLngRect_GetDirectedHausdorffDistance(self, *args)
    def GetHausdorffDistance(self, *args) -> "S1Angle" : return _s2.S2LatLngRect_GetHausdorffDistance(self, *args)
    def __eq__(self, *args) -> "bool" : return _s2.S2LatLngRect___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _s2.S2LatLngRect___ne__(self, *args)
    def ApproxEquals(self, *args) -> "bool" : return _s2.S2LatLngRect_ApproxEquals(self, *args)
    def Clone(self) -> "S2LatLngRect *" : return _s2.S2LatLngRect_Clone(self)
    def GetCapBound(self) -> "S2Cap" : return _s2.S2LatLngRect_GetCapBound(self)
    def GetRectBound(self) -> "S2LatLngRect" : return _s2.S2LatLngRect_GetRectBound(self)
    def VirtualContainsPoint(self, *args) -> "bool" : return _s2.S2LatLngRect_VirtualContainsPoint(self, *args)
    def MayIntersect(self, *args) -> "bool" : return _s2.S2LatLngRect_MayIntersect(self, *args)
    def Contains(self, *args) -> "bool" : return _s2.S2LatLngRect_Contains(self, *args)
    def Encode(self, *args) -> "void" : return _s2.S2LatLngRect_Encode(self, *args)
    def Decode(self, *args) -> "bool" : return _s2.S2LatLngRect_Decode(self, *args)
    def __str__(self) -> "string" : return _s2.S2LatLngRect___str__(self)
    __swig_destroy__ = _s2.delete_S2LatLngRect
    __del__ = lambda self : None;
S2LatLngRect_swigregister = _s2.S2LatLngRect_swigregister
S2LatLngRect_swigregister(S2LatLngRect)

def S2LatLngRect_FromCenterSize(*args) -> "S2LatLngRect" :
  return _s2.S2LatLngRect_FromCenterSize(*args)
S2LatLngRect_FromCenterSize = _s2.S2LatLngRect_FromCenterSize

def S2LatLngRect_FromPoint(*args) -> "S2LatLngRect" :
  return _s2.S2LatLngRect_FromPoint(*args)
S2LatLngRect_FromPoint = _s2.S2LatLngRect_FromPoint

def S2LatLngRect_FromPointPair(*args) -> "S2LatLngRect" :
  return _s2.S2LatLngRect_FromPointPair(*args)
S2LatLngRect_FromPointPair = _s2.S2LatLngRect_FromPointPair

def S2LatLngRect_Empty() -> "S2LatLngRect" :
  return _s2.S2LatLngRect_Empty()
S2LatLngRect_Empty = _s2.S2LatLngRect_Empty

def S2LatLngRect_Full() -> "S2LatLngRect" :
  return _s2.S2LatLngRect_Full()
S2LatLngRect_Full = _s2.S2LatLngRect_Full

def S2LatLngRect_FullLat() -> "R1Interval" :
  return _s2.S2LatLngRect_FullLat()
S2LatLngRect_FullLat = _s2.S2LatLngRect_FullLat

def S2LatLngRect_FullLng() -> "S1Interval" :
  return _s2.S2LatLngRect_FullLng()
S2LatLngRect_FullLng = _s2.S2LatLngRect_FullLng

class S2RegionCoverer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2RegionCoverer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, S2RegionCoverer, name)
    __repr__ = _swig_repr
    kDefaultMaxCells = _s2.S2RegionCoverer_kDefaultMaxCells
    def __init__(self): 
        this = _s2.new_S2RegionCoverer()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _s2.delete_S2RegionCoverer
    __del__ = lambda self : None;
    def set_min_level(self, *args) -> "void" : return _s2.S2RegionCoverer_set_min_level(self, *args)
    def set_max_level(self, *args) -> "void" : return _s2.S2RegionCoverer_set_max_level(self, *args)
    def min_level(self) -> "int" : return _s2.S2RegionCoverer_min_level(self)
    def max_level(self) -> "int" : return _s2.S2RegionCoverer_max_level(self)
    def set_level_mod(self, *args) -> "void" : return _s2.S2RegionCoverer_set_level_mod(self, *args)
    def level_mod(self) -> "int" : return _s2.S2RegionCoverer_level_mod(self)
    def set_max_cells(self, *args) -> "void" : return _s2.S2RegionCoverer_set_max_cells(self, *args)
    def max_cells(self) -> "int" : return _s2.S2RegionCoverer_max_cells(self)
    def GetCovering(self, *args) -> "void" : return _s2.S2RegionCoverer_GetCovering(self, *args)
    def GetInteriorCovering(self, *args) -> "void" : return _s2.S2RegionCoverer_GetInteriorCovering(self, *args)
    def GetCellUnion(self, *args) -> "void" : return _s2.S2RegionCoverer_GetCellUnion(self, *args)
    def GetInteriorCellUnion(self, *args) -> "void" : return _s2.S2RegionCoverer_GetInteriorCellUnion(self, *args)
    __swig_getmethods__["GetSimpleCovering"] = lambda x: _s2.S2RegionCoverer_GetSimpleCovering
    if _newclass:GetSimpleCovering = staticmethod(_s2.S2RegionCoverer_GetSimpleCovering)
S2RegionCoverer_swigregister = _s2.S2RegionCoverer_swigregister
S2RegionCoverer_swigregister(S2RegionCoverer)

def S2RegionCoverer_GetSimpleCovering(*args) -> "vector< S2CellId > *" :
  return _s2.S2RegionCoverer_GetSimpleCovering(*args)
S2RegionCoverer_GetSimpleCovering = _s2.S2RegionCoverer_GetSimpleCovering

class S2Cell(S2Region):
    __swig_setmethods__ = {}
    for _s in [S2Region]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2Cell, name, value)
    __swig_getmethods__ = {}
    for _s in [S2Region]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, S2Cell, name)
    __repr__ = _swig_repr
    __swig_getmethods__["FromFacePosLevel"] = lambda x: _s2.S2Cell_FromFacePosLevel
    if _newclass:FromFacePosLevel = staticmethod(_s2.S2Cell_FromFacePosLevel)
    def __init__(self, *args): 
        this = _s2.new_S2Cell(*args)
        try: self.this.append(this)
        except: self.this = this
    def id(self) -> "S2CellId" : return _s2.S2Cell_id(self)
    def face(self) -> "int" : return _s2.S2Cell_face(self)
    def level(self) -> "int" : return _s2.S2Cell_level(self)
    def orientation(self) -> "int" : return _s2.S2Cell_orientation(self)
    def is_leaf(self) -> "bool" : return _s2.S2Cell_is_leaf(self)
    def GetSizeIJ(self) -> "int" : return _s2.S2Cell_GetSizeIJ(self)
    def GetSizeST(self) -> "double" : return _s2.S2Cell_GetSizeST(self)
    def GetVertex(self, *args) -> "S2Point" : return _s2.S2Cell_GetVertex(self, *args)
    def GetVertexRaw(self, *args) -> "S2Point" : return _s2.S2Cell_GetVertexRaw(self, *args)
    def GetEdge(self, *args) -> "S2Point" : return _s2.S2Cell_GetEdge(self, *args)
    def GetEdgeRaw(self, *args) -> "S2Point" : return _s2.S2Cell_GetEdgeRaw(self, *args)
    def Subdivide(self, *args) -> "bool" : return _s2.S2Cell_Subdivide(self, *args)
    def GetCenter(self) -> "S2Point" : return _s2.S2Cell_GetCenter(self)
    def GetCenterRaw(self) -> "S2Point" : return _s2.S2Cell_GetCenterRaw(self)
    def AverageArea(self, *args) -> "double" : return _s2.S2Cell_AverageArea(self, *args)
    def ApproxArea(self) -> "double" : return _s2.S2Cell_ApproxArea(self)
    def ExactArea(self) -> "double" : return _s2.S2Cell_ExactArea(self)
    def Clone(self) -> "S2Cell *" : return _s2.S2Cell_Clone(self)
    def GetCapBound(self) -> "S2Cap" : return _s2.S2Cell_GetCapBound(self)
    def GetRectBound(self) -> "S2LatLngRect" : return _s2.S2Cell_GetRectBound(self)
    def MayIntersect(self, *args) -> "bool" : return _s2.S2Cell_MayIntersect(self, *args)
    def VirtualContainsPoint(self, *args) -> "bool" : return _s2.S2Cell_VirtualContainsPoint(self, *args)
    def Contains(self, *args) -> "bool" : return _s2.S2Cell_Contains(self, *args)
    def Encode(self, *args) -> "void" : return _s2.S2Cell_Encode(self, *args)
    def Decode(self, *args) -> "bool" : return _s2.S2Cell_Decode(self, *args)
    __swig_destroy__ = _s2.delete_S2Cell
    __del__ = lambda self : None;
S2Cell_swigregister = _s2.S2Cell_swigregister
S2Cell_swigregister(S2Cell)

def S2Cell_FromFacePosLevel(*args) -> "S2Cell" :
  return _s2.S2Cell_FromFacePosLevel(*args)
S2Cell_FromFacePosLevel = _s2.S2Cell_FromFacePosLevel

class S2CellUnion(S2Region):
    __swig_setmethods__ = {}
    for _s in [S2Region]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, S2CellUnion, name, value)
    __swig_getmethods__ = {}
    for _s in [S2Region]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, S2CellUnion, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _s2.new_S2CellUnion()
        try: self.this.append(this)
        except: self.this = this
    def Init(self, *args) -> "void" : return _s2.S2CellUnion_Init(self, *args)
    def InitSwap(self, *args) -> "void" : return _s2.S2CellUnion_InitSwap(self, *args)
    def InitRaw(self, *args) -> "void" : return _s2.S2CellUnion_InitRaw(self, *args)
    def InitRawSwap(self, *args) -> "void" : return _s2.S2CellUnion_InitRawSwap(self, *args)
    def Detach(self, *args) -> "void" : return _s2.S2CellUnion_Detach(self, *args)
    def num_cells(self) -> "int" : return _s2.S2CellUnion_num_cells(self)
    def cell_id(self, *args) -> "S2CellId const &" : return _s2.S2CellUnion_cell_id(self, *args)
    def cell_ids(self) -> "vector< S2CellId > const &" : return _s2.S2CellUnion_cell_ids(self)
    def Normalize(self) -> "bool" : return _s2.S2CellUnion_Normalize(self)
    def Denormalize(self, *args) -> "void" : return _s2.S2CellUnion_Denormalize(self, *args)
    def Pack(self, excess : 'int'=0) -> "void" : return _s2.S2CellUnion_Pack(self, excess)
    def Intersects(self, *args) -> "bool" : return _s2.S2CellUnion_Intersects(self, *args)
    def GetUnion(self, *args) -> "void" : return _s2.S2CellUnion_GetUnion(self, *args)
    def GetDifference(self, *args) -> "void" : return _s2.S2CellUnion_GetDifference(self, *args)
    def GetIntersection(self, *args) -> "void" : return _s2.S2CellUnion_GetIntersection(self, *args)
    def Expand(self, *args) -> "void" : return _s2.S2CellUnion_Expand(self, *args)
    def InitFromRange(self, *args) -> "void" : return _s2.S2CellUnion_InitFromRange(self, *args)
    def LeafCellsCovered(self) -> "uint64" : return _s2.S2CellUnion_LeafCellsCovered(self)
    def AverageBasedArea(self) -> "double" : return _s2.S2CellUnion_AverageBasedArea(self)
    def ApproxArea(self) -> "double" : return _s2.S2CellUnion_ApproxArea(self)
    def ExactArea(self) -> "double" : return _s2.S2CellUnion_ExactArea(self)
    def Clone(self) -> "S2CellUnion *" : return _s2.S2CellUnion_Clone(self)
    def GetCapBound(self) -> "S2Cap" : return _s2.S2CellUnion_GetCapBound(self)
    def GetRectBound(self) -> "S2LatLngRect" : return _s2.S2CellUnion_GetRectBound(self)
    def MayIntersect(self, *args) -> "bool" : return _s2.S2CellUnion_MayIntersect(self, *args)
    def VirtualContainsPoint(self, *args) -> "bool" : return _s2.S2CellUnion_VirtualContainsPoint(self, *args)
    def Encode(self, *args) -> "void" : return _s2.S2CellUnion_Encode(self, *args)
    def Decode(self, *args) -> "bool" : return _s2.S2CellUnion_Decode(self, *args)
    def Contains(self, *args) -> "bool" : return _s2.S2CellUnion_Contains(self, *args)
    __swig_destroy__ = _s2.delete_S2CellUnion
    __del__ = lambda self : None;
S2CellUnion_swigregister = _s2.S2CellUnion_swigregister
S2CellUnion_swigregister(S2CellUnion)

# This file is compatible with both classic and new-style classes.


